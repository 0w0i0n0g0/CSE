# Problem Set of Data Structure

<br>

## 변수의 Attribute들을 적어라.

- 이름
- 주소
- Type (크기와 어떻게 해석할 것인지)

<br>

## 배열의 정의를 제시하라.

연속된 주소, 동일한 Type.

<br>

## 포인터 정의를 제시하라.

Type이 주소인 변수.

저장하는 값을 주소로 해석하기로 약속한 변수.

그 주소로 가면 어떤 Type의 변수가 있는지 추가적으로 표시가 필요하다.

<br>

## log N의 의미.

2를 몇 번 곱하면 N이 나올까?

다르게 말하자면, N을 2로 몇 번 나눌 수 있을까?

<br>

## 변수 p가 int pointer일 때, 코드 ```*p = 3;``` 이 실행되는 과정을 CPU와 메모리 수준에서 상세히 설명하라.

*변수 p가 int pointer일 때* 라는 조건은 ```int *p;``` 라는 선언문으로 변수 p는 int 타입의 값이 위치한 주소를 가르키는 포인터라고 선언되어 있다는 뜻이다.

코드 ```*p = 3;``` 는 변수 p가 가르키는 int 값에 3을 할당하게 된다.

먼저 CPU는 address bus로 메모리에서 변수 p의 주소를 불러온다.

control bus로 read 명령을 수행해 변수 p에 저장된 값을 불러온다.

변수 p에는 int 타입을 가르키는 메모리 주소가 저장되어 있다.

읽어온 이 주소를 address bus에 로드한다.

data bus에 3이라는 정수 값을 불러온다.

control bus로 write 명령을 수행해 address bus에 로드된 주소에 정수 값 3을 저장한다.

<br>

## 다음 코드를 실행했을 때 출력되는 결과를 적어라.

```C++
int a, *p, *q, *r, **pp;
a = 3;
cout << *p << endl; // 안됨. p가 가르키는 것이 초기화가 안됨.
p = &a;
cout << *p << endl; // 3
q = &a;
r = p + q; r = p – q; // 안됨. 주소끼리 계산하려고 하는 것.
pp = &p;
cout << **pp << endl; // 3
```



<br>

## 다음 코드에서 변수 a의 값은 바뀌는지 안바뀌는지 확인하세요.

```c++
int a = 10;
int *p = &a;
int **pp = &p;

*pp = 20;
```

```int *p = &a;``` 에서 변수 p는 a의 주소를 담고 있다. 이때 *p는 a이다.

```int **pp = &p;``` 에서 변수 pp는 p의 주소를 담고 있다. *pp는 p이다. *p가 a이므로, **pp가 a이다.

여기서 ```*pp = 20;``` 을 수행하면, 변수 p가 20으로 바뀐다.

변수 p 자체는 주소일 뿐이다. 따라서 a 값을 변화시키지 못한다.

a 값을 변화시키려면 ```**pp = 20;``` 를 수행해야 한다.

<br>

## 수업 중에 제시한 미로찾기 알고리즘은 목적지로 가는 길이 있는 경우 그 길들 중 하나를 반드시 찾는다는 것을 증명하라.

### DFS 알고리즘

출발지를 $(0, 0)$, 목적지를 $(s, t)$라고 하자.

목적지로 가는 길이 있으므로 $(0, 0)$에서부터 목적지 $(s, t)$까지 가는 길 중 하나인 좌표의 배열을 $(0, 0), (a1, b1), (a2, b2), ···, (s, t)$라고 하자.

$(0, 0), (a1, b1), (a2, b2), ···, (s, t)$라는 좌표의 배열에서 서로 인접한 두 좌표의 차이는 1이며, 출발지에서 목적지까지 가는 길 이니, 이 배열 속의 모든 좌표는 '0', 즉, 갈 수 있는 길로 표시되어 있다.

__Base__ 

목적지가 $(0, 0)$이라고 하자. $(0, 0)$에서 출발하므로 이미 도착했다.

__Step__

목적지까지 가는 길 중 $(0, 0)$ 부터 $(a_k, b_k)$까지 도달했다고 가정하자.

만약,  $(a_k, b_k)$에 인접한 갈 수 있는 길의 위치가 $(a_{k+1}, b_{k+1})$ 뿐이면, 알고리즘이 $(a_{k+1}, b_{k+1})$를 방문함이 자명하다.

만약,  $(a_k, b_k)$에 인접한 갈 수 있는 길의 위치로 $(a_{k+1}, b_{k+1})$ 외에 (x, y)가 존재하고, $(a_{k+1}, b_{k+1})$가 아닌(x, y) 를 방문했다면 (x, y)를 방문하기 직전에  $(a_k, b_k)$의 좌표를 스택에 push 했을 것이다.

while문의 각 루프마다 push 또는 pop이 발생하므로, 길을 찾지 못했다면 결국 스택에서  $(a_k, b_k)$의 좌표가 pop되어  $(a_k, b_k)$로 돌아오게 될 것이다. 

또다시  $(a_k, b_k)$로 돌아와서 인접한 길 중에서 이미 방문한 $(x, y)$가 아닌 $(x', y')$가 있어서 방문해도 마찬가지 이유로 목적지까지의 길을 못찾게 되면 pop을 수행하여 $(a_k, b_k)$로 돌아오게 되고, 다른 좌표가 있어도 그 길이 목적지까지 가는 길이 아니라면, 결국에 목적지까지 가는 길인 $(a_{k+1}, b_{k+1})$을 방문하게 된다.

push와 pop이 반복되어 $(a_k, b_k)$로 돌아오지 않고 무한 루프에 빠지는 일은 없다. 

오직 '0', 즉 갈 수 있는 길의 위치의 좌표만 push할 수 있고, push한 뒤에는 이미 방문했다는 표시 '*'로 바뀌므로, 같은 좌표에서 push가 일어날 수 있는 횟수에 한계가 있기 때문이다.

$(a_k, b_k)$의 좌표가 pop되기 전에 while루프가 끝나 버릴 수 있는데, 이는  $(a_k, b_k)$로 돌아오지 않고 $(s, t)$에 도달한 경우밖에 없으므로 목적지에 도달하여 문제가 없다.

따라서 DFS 알고리즘은 미로에 목적지로 가는 길이 있을 때, 반드시 목적지까지 가는 길 중 하나를 찾게 된다.

<br>

### BFS 알고리즘

출발지를 $(0, 0)$, 목적지를 $(s, t)$라고 하자.

목적지로 가는 길이 있으므로 $(0, 0)$에서부터 목적지 $(s, t)$까지 가는 길 중 하나인 좌표의 배열을 $(0, 0), (a1, b1), (a2, b2), ···, (s, t)$라고 하자.

$(0, 0), (a1, b1), (a2, b2), ···, (s, t)$라는 좌표의 배열에서 서로 인접한 두 좌표의 차이는 1이며, 출발지에서 목적지까지 가는 길 이니, 이 배열 속의 모든 좌표는 '0', 즉, 갈 수 있는 길로 표시되어 있다.

__Base__ 

목적지가 $(0, 0)$이라고 하자. $(0, 0)$에서 출발하므로 이미 도착했다.

__Step__

목적지까지 가는 길 중 $(0, 0)$ 부터 $(a_k, b_k)$까지 도달했다고 가정하자.

만약, $(a_k, b_k)$에 인접한 갈 수 있는 길의 위치가 $(a_{k+1}, b_{k+1})$ 뿐이면, 알고리즘이 $(a_{k+1}, b_{k+1})$를 방문함이 자명하다.

만약, $(a_k, b_k)$에 인접한 갈 수 있는 길의 위치로 $(a_{k+1}, b_{k+1})$ 외에 다른 좌표 $(x, y), (x', y')$ 등 이 있어도, 갈 수 있는 좌표들 모두 Queue에 insert 되고, 나중에 언젠가 모두 방문하게 된다. 결국 언젠가 목적지까지 가는 길인 $(a_{k+1}, b_{k+1})$을 방문하게 된다.

큐에서 $(a_{k+1}, b_{k+1})$가 delete 되지 않고 방문하지 못하게 무한 루프에 빠지는 일은 없다. 

미로에서 갈 수 있는 길은 유한하므로, 큐에서 언젠가는 $(a_{k+1}, b_{k+1})$가 delete 되면서 좌표가 읽히고, 방문하게 된다.

따라서 BFS 알고리즘은 미로에 목적지로 가는 길이 있을 때, 반드시 목적지까지 가는 길을 찾게 된다.

<br>

## Linked List에서 인접한 두 노드를 교환하려 한다. 노드는 두 주소 P, Q로 주어진다. P가 앞 노드이다. 두 노드는 반드시 실제로 존재한다. 수업 시간에 제시한 더미 노드가 없는 기본형 Linked List를 가정하고 모든 경우가 정확히 해결되는 코드를 제시하라.

```c++
#include <iostream>

class Node {
public:
    int data;
    Node* next;
};

// 두 노드를 교환하는 함수
void swapNodes(Node*& head, Node* P, Node* Q) {
    // 두 노드가 동일한 경우 교환할 필요 없음
    if (P == Q || !head)
        return;

    // *P가 head가 가르키는 노드일 때
    if (P == head) {
        head = Q;
    } else {
        // P의 이전 노드를 찾음
        Node* prevP = head;
        while (prevP->next && prevP->next != P) {
            prevP = prevP->next;
        }
        // p의 이전 노드의 next를 주소 Q로 변경 
        prevP->next = Q;
    }

    // 노드를 교환
    Node* temp = Q->next;
    Q->next = P;
    P->next = temp;
}
```

<br>

## 하나의 노드에 k개의 정수를 저장하는 연결리스트가 있고, 노드 속 정수와 노드들끼리가 오름차순으로 정렬상태일 때, 이러한 연결리스트에서 search를 하는 알고리즘 제시 및 성능을 계산하시오.

연결리스트이기 때문에 중간 노드를 바로 찍어 탐색할 수 없다.

그러므로 이 상황에선 선형 탐색을 사용하는 것이 효율적이다.

첫 노드부터 찾으려고 하는 값에 대해 다음을 반복한다.

노드의 값이 찾으려고 하는 값과 같으면 탐색 성공, 작으면 다음 노드로 이동, 크면 해당 값이 존재하지 않음.  

따라서 주어진 정렬된 연결리스트에서 특정 값을 search한다면 O(n)이 걸린다.

그러나 이 O(n)은 정렬되지 않은 연결리스트에 비해서는 빠른 O(n)임을 알 수 있다.

<br>

## 링크드리스트의 탐색 알고리즘 제시하라.

링크드리스트의 haed에서 시작 노드로 이동, 찾고자 하는 값과 비교한다.

노드가 찾고자 하는 값이 아닐 때, 다음 노드로 이동한다.

다음 노드에서도 찾고자 하는 값과 비교하고, 아니라면 다음 노드로 이동하는 것을 반복.

만약 다음 노드가 NULL이라면 탐색 실패.

링크드리스트가 오름차순으로 정렬되어 있다면 노드의 값이 찾고자 하는 값보다 크다면 탐색 실패. 

<br>

## Doubly Linked List에서 Delete 기능을 구현하는 코드를 제시하라. 사용하는 Doubly Linked List는 -∞와 +∞를 더미 노드로 가지고 있는 구현이라고 가정한다. Search기능은 구현할 필요 없으며, 실패하는 경우 NULL을, 성공하는 경우 해당 노드의 주소를 리턴하는 것으로 가정하라. 문법이 100% 정확할 필요는 없다.

```C++
class Node {
public:
    int data;
    Node* next;
    Node* prev;
};

Node *delete(Node *head, int n) { // n은 삭제하고자 하는 값
    Node *N = search(n);
    if(N == nullptr){ // 삭제할 노드 없음.
        return NULL;
    } 
    // 더미 노드가 있으므로 N이 head이거나 끝일 떄를 고려하지 않는다.
    N->prev->next = N->next;
    N->next->prev = n->prev;
    return N;
}
```

<br>

## 두 가지 괄호, 즉 ()와 {}로 구성된 문자열이 주어진다. 이 문자열이 짝이 잘 맞는 괄호들로 구성되어 있는지 확인하는 알고리즘을 제시하라. 예를 들어 (){()}는 짝이 맞지만, ({)}는 짝이 맞지 않는 것이다. 알고리즘은 문자열 길이에 비례하는 시간에 동작하여야 한다.

빈 스택을 준비합니다.

문자열을 처음부터 순회하며 각 문자를 하나씩 처리합니다.

문자가 ( 또는 {인 경우, 해당 문자를 스택에 삽입합니다.

문자가 ) 또는 }인 경우, 스택에서 문자를 꺼냅니다. 이때 스택에서 꺼낸 문자와 짝이 맞으면 다음 문자로 넘어가고, 스택이 비어 있거나 스택에서 꺼낸 마지막 문자가 짝이 맞지 않으면 False를 반환합니다.

문자열의 모든 문자를 순회한 후, 스택이 비어 있으면 True, 스택이 비어있지 않으면 False를 반환합니다.

<br>

## 패턴 P가 있다. 어떤 텍스트 T에 P를 가지고 패턴매칭을 한 결과가 있다고 하자. 새로운 패턴 P' 는 P를 K번 이어붙인 것 일 때, 앞의 결과만 이용해서 P'를 T에서 찾는 O(n) 시간이 걸리는 알고리즘 제시하라.

패턴매칭을 한 결과 중에서, 패턴 P와 일치한다고 표시된 패턴매칭 결과(P의 길이가 4라면 4로 적혀진 곳)의 인덱스 포함 패턴 길이 이전 만큼은 패턴 P와 일치한다는 것을 알 수 있다. 

패턴매칭을 한 결과(길이 n)을 처음부터 순회하면서 패턴매칭 결과가 패턴 길이와 같은 곳의 인덱스를 찾는다. 그 인덱스에서 패턴 P의 길이부터 k*패턴 P의 길이까지의 위치가 턴매칭 결과가 패턴 길이와 같은 곳인지 판단. 아니라면 그 다음 인덱스로 넘어가고, 맞다면 이는 패턴 P가 k번 반복된 패턴 P'를 찾은 것.

패턴매칭을 한 결과(길이 n)을 처음부터 순회하면서 패턴매칭 결과가 패턴 길이와 같은 곳의 인덱스를 모두 찾는다.

이 인덱스들의 배열에서 한 인덱스에 대해 패턴 P의 길이부터 K * 패턴 P의 길이를 더했을 때 이것이 다른 인덱스와 같은지 모두 비교.

이 중에서 K개가 연결되어 있는 곳을 탐색하면 그 곳이 패턴 P'와 일치하는 곳임을 알 수 있다. 



따라서 텍스트 T의 길이 n만큼의 시간이 걸린다.

<br>

## 그래프에 한 노드에서 DFS를 시작했을 때, 연결된 다른 모든 노드를 방문한다를 증명하라.

스택을 이용한 DFS 사용.

한 노드에서 갈 수 있는 노드들 중 하나로 이동하고 현재 노드를 스택에 push 한다.

갈 수 있는 노드가 없을 때까지 이동하며 스택에 push 한다.

갈 수 있는 노드가 없다면 스택에서 pop 하여 그 노드에서 갈 수 있는 노드들 중 가보지 않은 노드로 이동하고 이를 반복한다.

### 귀류법으로 증명

위의 그래프 탐색 DFS가 연결된 다른 모든 노드를 방문하지 않는다고 가정하자.

1. 방문하지 않은 노드가 처음 시작한 노드와 직접 연결되어 있는 경우

이 때는 탐색 알고리즘에서 방문하지 않은 노드를 직접 방문하는 것이 자명하므로 가정이 틀렸다.

2. 방문하지 않은 노드가 처음 시작한 노드와 간접적으로 연결되어 있는 경우

방문하지 않은 노드와 시작한 노드 사이에는 이들을 간접적으로 연결해주는 노드들이 있다.

이 때 탐색 알고리즘은 간접적으로 연결해주는 노드들을 모두 방문할 것이고, 결과적으로 방문하지 않은 노드와 연결된 노드까지 방문할 것이다.

그렇다면 탐색 알고리즘은 그 노드에서 방문하지 않은 노드를 방문하게 되므로 가정이 틀렸다.

### 수학적 귀납법으로 증명

가정: 모두 연결된 n개의 노드로 구성된 그래프 G가 있다. DFS 알고리즘은 G에서 시작 노드 s로부터 연결된 모든 노드를 방문한다.

Base : 

그래프는 단 하나의 노드로만 구성된다고 하자. 그렇다면 DFS 알고리즘은 시작 노드 s를 방문하고 종료되므로 모든 연결된 노드를 방문했다.

Step : 

모두 연결된 n개의 노드로 구성된 그래프 G가 있다. DFS 알고리즘은 G에서 시작 노드 s로부터 연결된 모든 노드를 방문한다고 하자.

n + 1 개의 노드로 구성된 연결된 그래프 G'가 있다. G'은 G에 새로운 노드 v가 연결된 그래프이다.

가정에 의해 DFS 알고리즘은 s에서 시작해서 그래프 G의 연결된 모든 노드를 방문한다.

그렇다면 그래프 G에는 노드 v와 연결된 노드가 존재하는데 DFS 알고리즘은 이 노드에 반드시 방문한다.

DFS 알고리즘은 이 노드에서 노드와 연결되었지만 아직 방문하지 않은 노드 v가 있기 때문에 노드 v를 반드시 방문한다.

따라서 DFS 알고리즘은 모두 연결된 n + 1개의 노드로 구성된 그래프 G'에 대해서도 시작 노드 s로부터 연결된 모든 노드를 방문함을 증명할 수 있다.

<br>

## DFS 관련 증명문제, 시간복잡도도 계산



<br>

## KMP 알고리즘이 위치별로 어떤 일 일어나는지 서술하라.

문자열과 패턴이 주어진다.

Failure Function은 패턴이 k 까지 매치되었을 때 다음 번 시도할 수 있는 가장 긴 패턴의 앞부분의 길이이다.

문자열과 패턴의 문자를 비교하며 나간다. 

일치하면 그 다음 문자를 비교하고 그 위치에서 문자열과 패턴이 몇 글자까지 일치했는지 표시한다.

일치하지 않으면 이전 일치한 패턴의 길이 만큼에 해당하는 Failure Function의 패턴 위치부터 다시 탐색해 나간다.

<br>

## BST의 한 노드 아래의 SUBTREE의 값들은 전체 TREE를 정렬했을 때 연속으로 등장하는걸 증명하라.

**이진 탐색 트리 (BST)**는 각 노드에 하나의 키를 저장하며, 다음 조건을 만족한다.

1. 각 노드에 대해, 그 노드의 왼쪽 서브트리에 있는 key들은 그 노드의 key보다 항상 작다.
2. 오른쪽 서브트리에 있는 key들은 그 노드의 key보다 항상 크다.

한 노드의 왼쪽 서브트리 속 노드들은 그 노드보다 항상 작고, 한 노드의 오른쪽 서브트리 속 노드들은 그 노드보다 항상 크므로, 크기 순서로 정렬하게 되면 왼쪽 서브트리 속 노드들, 한 노드, 오른쪽 서브트리 속 노드들 순으로 나오게 된다.

<br>

## 기본 Binary Search Tree에 1부터 n까지 n개의 값이 다음과 같은 순서로 Insert된다. [1, n, 2, n-1, 3, n-2, ...] 어떤 Tree가 만들어지는가? 또, 가장 Height가 낮은 Tree가 만들어지려면 어떤 순서로 Insert가 일어나야 하는가? 가능한 순서가 여러 가지 존재하는 경우 하나만 제시하면 된다. 두 경우 모두 처음에 Tree는 비어 있는 것으로 가정한다.

<br>